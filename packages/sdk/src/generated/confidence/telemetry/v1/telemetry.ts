// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v5.26.1
// source: confidence/telemetry/v1/telemetry.proto

/* eslint-disable */
import { BinaryWriter } from '@bufbuild/protobuf/wire';

export const protobufPackage = 'confidence.telemetry.v1';

export enum Platform {
  PLATFORM_UNSPECIFIED = 0,
  PLATFORM_JAVA = 1,
  PLATFORM_KOTLIN = 2,
  PLATFORM_SWIFT = 3,
  PLATFORM_JS_WEB = 4,
  PLATFORM_JS_SERVER = 5,
  PLATFORM_PYTHON = 6,
  PLATFORM_GO = 7,
  PLATFORM_RUBY = 8,
  PLATFORM_RUST = 9,
  PLATFORM_FLUTTER_IOS = 10,
  PLATFORM_FLUTTER_ANDROID = 11,
  UNRECOGNIZED = -1,
}

export function platformFromJSON(object: any): Platform {
  switch (object) {
    case 0:
    case 'PLATFORM_UNSPECIFIED':
      return Platform.PLATFORM_UNSPECIFIED;
    case 1:
    case 'PLATFORM_JAVA':
      return Platform.PLATFORM_JAVA;
    case 2:
    case 'PLATFORM_KOTLIN':
      return Platform.PLATFORM_KOTLIN;
    case 3:
    case 'PLATFORM_SWIFT':
      return Platform.PLATFORM_SWIFT;
    case 4:
    case 'PLATFORM_JS_WEB':
      return Platform.PLATFORM_JS_WEB;
    case 5:
    case 'PLATFORM_JS_SERVER':
      return Platform.PLATFORM_JS_SERVER;
    case 6:
    case 'PLATFORM_PYTHON':
      return Platform.PLATFORM_PYTHON;
    case 7:
    case 'PLATFORM_GO':
      return Platform.PLATFORM_GO;
    case 8:
    case 'PLATFORM_RUBY':
      return Platform.PLATFORM_RUBY;
    case 9:
    case 'PLATFORM_RUST':
      return Platform.PLATFORM_RUST;
    case 10:
    case 'PLATFORM_FLUTTER_IOS':
      return Platform.PLATFORM_FLUTTER_IOS;
    case 11:
    case 'PLATFORM_FLUTTER_ANDROID':
      return Platform.PLATFORM_FLUTTER_ANDROID;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return Platform.UNRECOGNIZED;
  }
}

export function platformToJSON(object: Platform): string {
  switch (object) {
    case Platform.PLATFORM_UNSPECIFIED:
      return 'PLATFORM_UNSPECIFIED';
    case Platform.PLATFORM_JAVA:
      return 'PLATFORM_JAVA';
    case Platform.PLATFORM_KOTLIN:
      return 'PLATFORM_KOTLIN';
    case Platform.PLATFORM_SWIFT:
      return 'PLATFORM_SWIFT';
    case Platform.PLATFORM_JS_WEB:
      return 'PLATFORM_JS_WEB';
    case Platform.PLATFORM_JS_SERVER:
      return 'PLATFORM_JS_SERVER';
    case Platform.PLATFORM_PYTHON:
      return 'PLATFORM_PYTHON';
    case Platform.PLATFORM_GO:
      return 'PLATFORM_GO';
    case Platform.PLATFORM_RUBY:
      return 'PLATFORM_RUBY';
    case Platform.PLATFORM_RUST:
      return 'PLATFORM_RUST';
    case Platform.PLATFORM_FLUTTER_IOS:
      return 'PLATFORM_FLUTTER_IOS';
    case Platform.PLATFORM_FLUTTER_ANDROID:
      return 'PLATFORM_FLUTTER_ANDROID';
    case Platform.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface Monitoring {
  libraryTraces: LibraryTraces[];
  platform: Platform;
}

export interface LibraryTraces {
  library: LibraryTraces_Library;
  libraryVersion: string;
  traces: LibraryTraces_Trace[];
}

export enum LibraryTraces_Library {
  LIBRARY_UNSPECIFIED = 0,
  LIBRARY_CONFIDENCE = 1,
  LIBRARY_OPEN_FEATURE = 2,
  LIBRARY_REACT = 3,
  UNRECOGNIZED = -1,
}

export function libraryTraces_LibraryFromJSON(object: any): LibraryTraces_Library {
  switch (object) {
    case 0:
    case 'LIBRARY_UNSPECIFIED':
      return LibraryTraces_Library.LIBRARY_UNSPECIFIED;
    case 1:
    case 'LIBRARY_CONFIDENCE':
      return LibraryTraces_Library.LIBRARY_CONFIDENCE;
    case 2:
    case 'LIBRARY_OPEN_FEATURE':
      return LibraryTraces_Library.LIBRARY_OPEN_FEATURE;
    case 3:
    case 'LIBRARY_REACT':
      return LibraryTraces_Library.LIBRARY_REACT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return LibraryTraces_Library.UNRECOGNIZED;
  }
}

export function libraryTraces_LibraryToJSON(object: LibraryTraces_Library): string {
  switch (object) {
    case LibraryTraces_Library.LIBRARY_UNSPECIFIED:
      return 'LIBRARY_UNSPECIFIED';
    case LibraryTraces_Library.LIBRARY_CONFIDENCE:
      return 'LIBRARY_CONFIDENCE';
    case LibraryTraces_Library.LIBRARY_OPEN_FEATURE:
      return 'LIBRARY_OPEN_FEATURE';
    case LibraryTraces_Library.LIBRARY_REACT:
      return 'LIBRARY_REACT';
    case LibraryTraces_Library.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export enum LibraryTraces_TraceId {
  TRACE_ID_UNSPECIFIED = 0,
  TRACE_ID_RESOLVE_LATENCY = 1,
  TRACE_ID_STALE_FLAG = 2,
  TRACE_ID_FLAG_TYPE_MISMATCH = 3,
  TRACE_ID_WITH_CONTEXT = 4,
  UNRECOGNIZED = -1,
}

export function libraryTraces_TraceIdFromJSON(object: any): LibraryTraces_TraceId {
  switch (object) {
    case 0:
    case 'TRACE_ID_UNSPECIFIED':
      return LibraryTraces_TraceId.TRACE_ID_UNSPECIFIED;
    case 1:
    case 'TRACE_ID_RESOLVE_LATENCY':
      return LibraryTraces_TraceId.TRACE_ID_RESOLVE_LATENCY;
    case 2:
    case 'TRACE_ID_STALE_FLAG':
      return LibraryTraces_TraceId.TRACE_ID_STALE_FLAG;
    case 3:
    case 'TRACE_ID_FLAG_TYPE_MISMATCH':
      return LibraryTraces_TraceId.TRACE_ID_FLAG_TYPE_MISMATCH;
    case 4:
    case 'TRACE_ID_WITH_CONTEXT':
      return LibraryTraces_TraceId.TRACE_ID_WITH_CONTEXT;
    case -1:
    case 'UNRECOGNIZED':
    default:
      return LibraryTraces_TraceId.UNRECOGNIZED;
  }
}

export function libraryTraces_TraceIdToJSON(object: LibraryTraces_TraceId): string {
  switch (object) {
    case LibraryTraces_TraceId.TRACE_ID_UNSPECIFIED:
      return 'TRACE_ID_UNSPECIFIED';
    case LibraryTraces_TraceId.TRACE_ID_RESOLVE_LATENCY:
      return 'TRACE_ID_RESOLVE_LATENCY';
    case LibraryTraces_TraceId.TRACE_ID_STALE_FLAG:
      return 'TRACE_ID_STALE_FLAG';
    case LibraryTraces_TraceId.TRACE_ID_FLAG_TYPE_MISMATCH:
      return 'TRACE_ID_FLAG_TYPE_MISMATCH';
    case LibraryTraces_TraceId.TRACE_ID_WITH_CONTEXT:
      return 'TRACE_ID_WITH_CONTEXT';
    case LibraryTraces_TraceId.UNRECOGNIZED:
    default:
      return 'UNRECOGNIZED';
  }
}

export interface LibraryTraces_Trace {
  id: LibraryTraces_TraceId;
  /** only used for timed events. */
  millisecondDuration?: number | undefined;
}

export const Monitoring: MessageFns<Monitoring> = {
  encode(message: Monitoring, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.libraryTraces) {
      LibraryTraces.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.platform !== 0) {
      writer.uint32(16).int32(message.platform);
    }
    return writer;
  },

  fromJSON(object: any): Monitoring {
    return {
      libraryTraces: globalThis.Array.isArray(object?.libraryTraces)
        ? object.libraryTraces.map((e: any) => LibraryTraces.fromJSON(e))
        : [],
      platform: isSet(object.platform) ? platformFromJSON(object.platform) : 0,
    };
  },

  toJSON(message: Monitoring): unknown {
    const obj: any = {};
    if (message.libraryTraces?.length) {
      obj.libraryTraces = message.libraryTraces.map(e => LibraryTraces.toJSON(e));
    }
    if (message.platform !== 0) {
      obj.platform = platformToJSON(message.platform);
    }
    return obj;
  },
};

export const LibraryTraces: MessageFns<LibraryTraces> = {
  encode(message: LibraryTraces, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.library !== 0) {
      writer.uint32(8).int32(message.library);
    }
    if (message.libraryVersion !== '') {
      writer.uint32(18).string(message.libraryVersion);
    }
    for (const v of message.traces) {
      LibraryTraces_Trace.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  fromJSON(object: any): LibraryTraces {
    return {
      library: isSet(object.library) ? libraryTraces_LibraryFromJSON(object.library) : 0,
      libraryVersion: isSet(object.libraryVersion) ? globalThis.String(object.libraryVersion) : '',
      traces: globalThis.Array.isArray(object?.traces)
        ? object.traces.map((e: any) => LibraryTraces_Trace.fromJSON(e))
        : [],
    };
  },

  toJSON(message: LibraryTraces): unknown {
    const obj: any = {};
    if (message.library !== 0) {
      obj.library = libraryTraces_LibraryToJSON(message.library);
    }
    if (message.libraryVersion !== '') {
      obj.libraryVersion = message.libraryVersion;
    }
    if (message.traces?.length) {
      obj.traces = message.traces.map(e => LibraryTraces_Trace.toJSON(e));
    }
    return obj;
  },
};

export const LibraryTraces_Trace: MessageFns<LibraryTraces_Trace> = {
  encode(message: LibraryTraces_Trace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.millisecondDuration !== undefined) {
      writer.uint32(16).uint64(message.millisecondDuration);
    }
    return writer;
  },

  fromJSON(object: any): LibraryTraces_Trace {
    return {
      id: isSet(object.id) ? libraryTraces_TraceIdFromJSON(object.id) : 0,
      millisecondDuration: isSet(object.millisecondDuration)
        ? globalThis.Number(object.millisecondDuration)
        : undefined,
    };
  },

  toJSON(message: LibraryTraces_Trace): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = libraryTraces_TraceIdToJSON(message.id);
    }
    if (message.millisecondDuration !== undefined) {
      obj.millisecondDuration = Math.round(message.millisecondDuration);
    }
    return obj;
  },
};

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
